<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Chapter3</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-require-zoom-fix foreignobject { font-size: var(--mermaid-font-zoom); }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

/* open-sans-regular - latin-ext_latin */
  /* open-sans-italic - latin-ext_latin */
    /* open-sans-700 - latin-ext_latin */
    /* open-sans-700italic - latin-ext_latin */
  html {
    font-size: 16px;
}

body {
    font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

/*@media print {
    .typora-export h1,
    .typora-export h2 {
        border-bottom: none;
        padding-bottom: initial;
    }

    .typora-export h1::after,
    .typora-export h2::after {
        content: "";
        display: block;
        height: 100px;
        margin-top: -96px;
        border-top: 1px solid #eee;
    }
}*/

h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table th:first-child,
table td:first-child {
    margin-top: 0;
}
table th:last-child,
table td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}


</style>
</head>
<body class='typora-export os-windows'>
<div id='write'  class=''><h1><a name="qcsg" class="md-header-anchor"></a><a href='..'><span>QCSG</span></a></h1><h3>The Quantum Computing Survival Guide</h3><h5><a name="written-by-river-way" class="md-header-anchor"></a><span>Written by River Way</span></h5><div class='md-toc' mdtype='toc'><p class="md-toc-content" role="list"><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n222"><a class="md-toc-inner" href="#qcsg">QCSG</a></span><span role="listitem" class="md-toc-item md-toc-h5" data-ref="n225"><a class="md-toc-inner" href="#written-by-river-way">Written by River Way</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n227"><a class="md-toc-inner" href="#chapter-3---quantum-circuits">Chapter 3:   Quantum Circuits</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n229"><a class="md-toc-inner" href="#31qcsg---definition-of-a-gate">3.1   Definition of a Gate</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n234"><a class="md-toc-inner" href="#quantum-gates">Quantum Gates</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n243"><a class="md-toc-inner" href="#recovering-angles-from-vector-representation">Recovering Angles from Vector Representation</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n254"><a class="md-toc-inner" href="#32qcsg---rotation-gates">3.2   Rotation Gates</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n266"><a class="md-toc-inner" href="#common-gates">Common Gates</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n270"><a class="md-toc-inner" href="#floating-point-rotations">Floating Point Rotations</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n279"><a class="md-toc-inner" href="#33qcsg---alternate-axes">3.3   Alternate Axes</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n285"><a class="md-toc-inner" href="#the-hadamard-axis">The Hadamard Axis</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n300"><a class="md-toc-inner" href="#arbitrary-axes">Arbitrary Axes</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n312"><a class="md-toc-inner" href="#34qcsg---quantum-registers">3.4   Quantum Registers</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n339"><a class="md-toc-inner" href="#quantum-circuits">Quantum Circuits</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n347"><a class="md-toc-inner" href="#matrix-tensor-product">Matrix Tensor Product</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n357"><a class="md-toc-inner" href="#35qcsg---controlled-gates">3.5   Controlled Gates</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n359"><a class="md-toc-inner" href="#controlled-not-gate">Controlled Not Gate</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n371"><a class="md-toc-inner" href="#swap-gate">SWAP Gate</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n378"><a class="md-toc-inner" href="#controlled-z-gate">Controlled Z Gate</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n390"><a class="md-toc-inner" href="#controlled-u-gate">Controlled U Gate</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n397"><a class="md-toc-inner" href="#circuit-specifications">Circuit Specifications</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n401"><a class="md-toc-inner" href="#36qcsg---quantum-programming">3.6   Quantum Programming</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n408"><a class="md-toc-inner" href="#qiskit">Qiskit</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n410"><a class="md-toc-inner" href="#q">Q#</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n412"><a class="md-toc-inner" href="#cirq">Cirq</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n414"><a class="md-toc-inner" href="#37qcsg---case-study-googles-quantum-supremacy">3.7   Case Study: Google's Quantum Supremacy</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n434"><a class="md-toc-inner" href="#quantum-vs-classical">Quantum vs. Classical</a></span><span role="listitem" class="md-toc-item md-toc-h4" data-ref="n438"><a class="md-toc-inner" href="#ibms-rebuttal">IBM's Rebuttal</a></span></p></div><h2><a name="chapter-3---quantum-circuits" class="md-header-anchor"></a><span>Chapter 3:   Quantum Circuits</span></h2><p><span>We have begun discussing the process of transforming a qubit, but we do not have a concise notation to describe many sequential transformations. This chapter will introduce the concept of </span><em><span>quantum circuits</span></em><span>, a quantum analogue to </span><em><span>classical circuits</span></em><span>. Quantum circuits are a widely used system of notation used to describe operations on the quantum state.</span></p><h3><a name="31qcsg---definition-of-a-gate" class="md-header-anchor"></a><a href='#qcsg'><span>3.1</span></a><span>   Definition of a Gate</span></h3><p><span>Classical computers perform all of their operations through logic </span><em><span>gates</span></em><span>. What are gates? An in abstract sense, a gate is simply a boolean function which maps </span><span class='math-in-toc'>$n$</span><span> input boolean variables to </span><span class='math-in-toc'>$m$</span><span> output boolean variables </span><span class='math-in-toc'>$f:\{0,1\}^n\rightarrow\{0,1\}^m$</span><span>. </span></p><p><span>In computer science, we can represent any boolean function with a </span><em><span>truth table</span></em><span> which contains </span><span class='math-in-toc'>$2^n$</span><span> rows, one for each possible combination of inputs.</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n232" cid="n232" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{matrix}
\begin{array}{cc|c}
x_1 & x_2 & x_1\and x_2 \\
\hline 
0 & 0 & 0 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
1 & 1 & 1
\end{array} \\ \\ \text{AND gate}
\end{matrix}

\qquad\qquad

\begin{matrix}
\begin{array}{cc|c}
x_1 & x_2 & x_1\or x_2 \\
\hline 
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 1
\end{array} \\ \\ \text{OR gate}
\end{matrix}

\qquad\qquad

\begin{matrix}
\begin{array}{cc|c}
x_1 & x_2 & x_1\oplus x_2 \\
\hline 
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0
\end{array} \\ \\ \text{XOR gate}
\end{matrix}

\qquad\qquad

\begin{matrix}
\begin{array}{c|c}
x_1 & \neg x_1\\
\hline 
0 & 1 \\
1 & 0 \\
\end{array}  \\ \\ \\ \\ \text{NOT gate}
\end{matrix}</script></div></div><p><span>The above truth tables describe four common classical logic gates seen in computer science. A set of gates is said to be </span><em><span>universal</span></em><span> if every boolean function can be implemented using a sequence of gates only inside the set. One such set of universal gates is {AND, OR, NOT}, but there are many universal sets. The set {NAND} is a universal set which only contains one gate inside, which is the AND gate followed immediately by the NOT gate. </span></p><h4><a name="quantum-gates" class="md-header-anchor"></a><span>Quantum Gates</span></h4><p><span>Gates are some operation which acts on the input to produce an output. Quantum gates follow that same definition by operating on a quantum state to produce a different quantum state. However there are some characteristics which are required for a quantum gate to be valid. First, recall our notation to describe a quantum state of 1 qubit:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n236" cid="n236" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|\psi\rangle=\alpha|0\rangle+\beta|1\rangle=\cos(\frac{\theta}{2})|0\rangle+e^{i\phi}\sin(\frac{\theta}{2})|1\rangle=
\begin{bmatrix}
\cos(\frac{\theta}{2}) \\
e^{i\phi}\sin(\frac{\theta}{2})
\end{bmatrix}</script></div></div><p><span>Since our quantum state is just a vector, a quantum gate is a matrix which acts on our quantum state through matrix-vector multiplication. Specifically, the gate is a square matrix whose size is equal to the quantum state. A gate acting on our 1 qubit system is a 2x2 matrix with complex entries. Another requirement for quantum gates is that their matrix needs to be </span><em><span>unitary</span></em><span>. A unitary matrix has the property that its adjoint (conjugate-transpose) is the same as its inverse.</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n238" cid="n238" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">U^\dagger=U^{-1} \\
UU^\dagger=U^\dagger U=I \\
|\text{det}(U)|=1</script></div></div><p><span>The conjugate transpose was introduced as a method of converting between kets and bras in Dirac notation. Another property of these gate matrices is that all of the columns and rows are orthonormal. This means the absolute value of the determinant is 1. </span></p><p><span>Since every quantum gate is unitary, that means it is also </span><em><span>reversible</span></em><span>. Consider some sequence of quantum gates </span><span class='math-in-toc'>$U_1,U_2,...,U_n$</span><span>. The result of applying the sequence can be converted back into the original state by applying the adjoint of each in reverse order:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n241" cid="n241" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">U_n \cdots U_2U_1|\psi\rangle=|\psi'\rangle \\
U_1^\dagger U_2^\dagger\cdots U_n^\dagger|\psi'\rangle=|\psi\rangle</script></div></div><p><span>The transformations to the Bloch sphere discussed in the previous chapter can be described with quantum gates, except for collapse. The process of measuring a qubit cannot be expressed as a 2x2 unitary matrix since it collapses the quantum state into classical data. Since collapse is not reversible, we need to measure an infinite number of qubits to perfectly reconstruct the quantum state. </span></p><h4><a name="recovering-angles-from-vector-representation" class="md-header-anchor"></a><span>Recovering Angles from Vector Representation</span></h4><p><span>In the following sections, we will be discussing quantum states in their vector forms since the ket forms are notationally verbose. Converting between the coordinates of the Bloch sphere and the vector representation of the qubit is common when working with computer programs. It can valuable to learn the different data types used for containing a qubit&#39;s data and how to convert between them. Starting with complex numbers, they can either be stored in Euclidean or polar form:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n245" cid="n245" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">a+bi=re^{i\varphi} \\
re^{i\varphi}\rightarrow r(\cos\varphi+i\sin\varphi) \\
a+bi\rightarrow \sqrt{a^2+b^2}e^{i\text{atan2}(a,b)}</script></div></div><p><span>The function </span><span class='math-in-toc'>$\text{atan2}(x,y)$</span><span> is a perfect inverse trigonometric function which returns the angle from the position X axis to the point defined by </span><span class='math-in-toc'>$x$</span><span> and </span><span class='math-in-toc'>$y$</span><span>. Traditional inverse trigonometric functions have domain restrictions which make them difficult to use in programs. Our function </span><span class='math-in-toc'>$\text{atan2}$</span><span> can be defined a number of ways, but we will use:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n247" cid="n247" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\text{atan2}(x,y)=\begin{cases}
\text{acos}(\frac{x}{\sqrt{x^2+y^2}}) &  y\geq0 \\
-\text{acos}(\frac{x}{\sqrt{x^2+y^2}}) & y<0
\end{cases}</script></div></div><p><span>The denominator inside the </span><span class='math-in-toc'>$\text{acos}$</span><span> function can be disregarded if it is assumed that the point is distance </span><span class='math-in-toc'>$1$</span><span> away from the origin.</span></p><p><span>Typically our quantum state vector will hold Euclidean complex numbers since they are the easiest to work with in programs. Our first step to convert the vector contents to polar complex numbers:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n250" cid="n250" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{bmatrix}
a_1+b_1i \\ a_2+b_2i
\end{bmatrix}
\rightarrow
\begin{bmatrix}
r_1e^{i\varphi_1} \\ r_2e^{i\varphi_2}
\end{bmatrix}
=
\begin{bmatrix}
\cos(\frac{\theta}{2}) \\
e^{i\phi}\sin(\frac{\theta}{2})
\end{bmatrix}</script></div></div><p><span>Now we can easily calculate our spherical coordinates using our polar complex numbers:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n252" cid="n252" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\theta=2\ \text{atan2}(r_1,r_2) \\
\phi=\varphi_2-\varphi_1</script></div></div><p><span>The phase needs to be calculated as the difference between the polar angles because of the qubit&#39;s global phase. Recall that every amplitude of a quantum state can be multiplied by </span><span class='math-in-toc'>$e^{ia}$</span><span> and there will be no observable changes. We choose to set </span><span class='math-in-toc'>$a=-\varphi_1$</span><span> so the first amplitude is real. Many quantum gates change a quantum state&#39;s global phase, so we cannot assume </span><span class='math-in-toc'>$|0\rangle$</span><span> will always stay real without manually setting it.</span></p><h3><a name="32qcsg---rotation-gates" class="md-header-anchor"></a><a href='#qcsg'><span>3.2</span></a><span>   Rotation Gates</span></h3><p><span>Quantum gates can be described by unitary matrices acting on our vector representation of a quantum state. The rotations around the Bloch sphere also have matrix forms, as shown below.</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n256" cid="n256" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{equation}\begin{aligned}
X^\Delta&=\begin{bmatrix}
\cos(\frac{\Delta\pi}{2}) & -i\sin(\frac{\Delta\pi}{2}) \\ -i\sin(\frac{\Delta\pi}{2}) & \cos(\frac{\Delta\pi}{2})
\end{bmatrix} \\ 
Y^\Delta&=\begin{bmatrix}
\cos(\frac{\Delta\pi}{2}) & -\sin(\frac{\Delta\pi}{2}) \\ \sin(\frac{\Delta\pi}{2}) & \cos(\frac{\Delta\pi}{2})
\end{bmatrix} \\ 
Z^\Delta&=\begin{bmatrix}
1 & 0 \\ 0 & e^{i\Delta\pi}
\end{bmatrix}
\end{aligned}\end{equation}</script></div></div><p><span>These gates are known as the </span><strong><span>Rotation Operators</span></strong><span> and form the foundation for all single qubit transformations. Every other single qubit gate can be expressed as a combination of these three gates. Technically, only 2 of the 3 are necessary because one can be expressed from the other two. For example, an X rotation can be decomposed into:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n258" cid="n258" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{equation}\begin{aligned}
X^\Delta&=Z^{-0.5}Y^\Delta Z^{0.5}\\ &=
\begin{bmatrix}
1 & 0 \\ 0 & e^{-i0.5\pi}
\end{bmatrix}
\begin{bmatrix}
\cos(\frac{\Delta\pi}{2}) & -\sin(\frac{\Delta\pi}{2}) \\ \sin(\frac{\Delta\pi}{2}) & \cos(\frac{\Delta\pi}{2})
\end{bmatrix}
\begin{bmatrix}
1 & 0 \\ 0 & e^{i0.5\pi}
\end{bmatrix}
\\ &=
\begin{bmatrix}
\cos(\frac{\Delta\pi}{2}) & -e^{i0.5\pi}\sin(\frac{\Delta\pi}{2}) \\ e^{-i0.5\pi}\sin(\frac{\Delta\pi}{2}) & e^{i0.5\pi}e^{-i0.5\pi}\cos(\frac{\Delta\pi}{2})
\end{bmatrix}
\\ &=
\begin{bmatrix}
\cos(\frac{\Delta\pi}{2}) & -i\sin(\frac{\Delta\pi}{2}) \\ -i\sin(\frac{\Delta\pi}{2}) & \cos(\frac{\Delta\pi}{2})
\end{bmatrix}
\end{aligned}\end{equation}</script></div></div><p><span>The special case when </span><span class='math-in-toc'>$\Delta=1$</span><span> produces the set of </span><strong><span>Pauli Gates</span></strong><span> shown below. Another common system of notation for the Pauli gates is </span><span class='math-in-toc'>$\sigma_x, \sigma_y, \sigma_z$</span><span>. </span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n260" cid="n260" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{equation}\begin{aligned}
X&=\begin{bmatrix}
0 & 1 \\ 1 & 0
\end{bmatrix} \\ 
Y&=\begin{bmatrix}
0 & -i \\ i & 0
\end{bmatrix} \\ 
Z&=\begin{bmatrix}
1 & 0 \\ 0 & -1
\end{bmatrix}
\end{aligned}\end{equation}</script></div></div><p><span>All of the Pauli gates are their own inverse, which means:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n262" cid="n262" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">X^2=Y^2=Z^2=-iXYZ=I</script></div></div><p><span>When all three of the Pauli matrices are multiplied together, it produces the identity matrix, except for the </span><span class='math-in-toc'>$-i$</span><span> scalar attached in front. The </span><span class='math-in-toc'>$-i$</span><span> is a global phase! This global phase is the same reason that the Pauli X and Y gate differ from what the rotation gate produces when </span><span class='math-in-toc'>$\Delta=1$</span><span>:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n264" cid="n264" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">X^1=\begin{bmatrix}
\cos(\frac{\pi}{2}) & -i\sin(\frac{\pi}{2}) \\ -i\sin(\frac{\pi}{2}) & \cos(\frac{\pi}{2})
\end{bmatrix}
=
\begin{bmatrix}
0 & -i \\ -i & 0
\end{bmatrix}
=-i
\begin{bmatrix}
0 & 1 \\ 1 & 0
\end{bmatrix}</script></div></div><p><span>Global phase can apply to a quantum gate as well, this means different matrices can perform the same operation. The gates </span><span class='math-in-toc'>$U_1$</span><span> and </span><span class='math-in-toc'>$U_2$</span><span> are equivalent if they can be expressed as </span><span class='math-in-toc'>$U_1=e^{i\gamma}U_2$</span><span> for some value </span><span class='math-in-toc'>$\gamma$</span><span>. </span></p><h4><a name="common-gates" class="md-header-anchor"></a><span>Common Gates</span></h4><p><span>Here are some common gates and their adjoints which appear in quantum computing literature:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n268" cid="n268" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">S=\sqrt{Z}=\begin{bmatrix}1 & 0 \\ 0 & i\end{bmatrix} \\
S^\dagger=Z\sqrt{Z}=\begin{bmatrix}1 & 0 \\ 0 & -i\end{bmatrix} \\
T=\sqrt{S}= \sqrt[4]{Z} =\begin{bmatrix}1 & 0 \\ 0 & \frac{1}{\sqrt2}(1+i)\end{bmatrix} \\
T^\dagger=ZS\sqrt{S} =\begin{bmatrix}1 & 0 \\ 0 & \frac{1}{\sqrt2}(1-i)\end{bmatrix} \\
\sqrt{NOT}=\sqrt{\neg}=\sqrt{X}=\frac{1}{2}\begin{bmatrix}1+i & 1-i \\ 1-i & 1+i\end{bmatrix}= \frac{1}{\sqrt2}\begin{bmatrix}1 & -i \\ -i & 1\end{bmatrix} \\
\sqrt{NOT}^\dagger=\sqrt{\neg}^\dagger=X\sqrt{X}=\frac{1}{2}\begin{bmatrix}1-i & 1+i \\ 1+i & 1-i\end{bmatrix}= \frac{-1}{\sqrt2}\begin{bmatrix}1 & i \\ i & 1\end{bmatrix}</script></div></div><p><span>A rotation matrix&#39;s adjoint is equivalent to rotating clockwise instead of counterclockwise. That is to say, </span><span class='math-in-toc'>${X^{\Delta}}^{\dagger}=X^{-\Delta}=X^{2-\Delta}$</span><span>, since rotating one way by </span><span class='math-in-toc'>$\Delta$</span><span> and then immediately rotating the other way by </span><span class='math-in-toc'>$\Delta$</span><span> will produce an identity operation.</span></p><h4><a name="floating-point-rotations" class="md-header-anchor"></a><span>Floating Point Rotations</span></h4><p><span>Classical computers don&#39;t always store precise values. For a value like </span><span class='math-in-toc'>$\pi$</span><span>, it would require an infinite number of bits to perfectly represent. Instead, classical computers store estimations using a fixed number of bits which are called </span><em><span>floating point numbers</span></em><span>. It may not be possible to rotate around the Bloch sphere by an arbitrary amount with perfect precision, so we will have to use approximations. </span></p><p><span>The </span><strong><span>Solovay-Kitaev Theorem</span></strong><span> implies any single qubit gate can be approximated using </span><span class='math-in-toc'>$O(\log^c(\frac{1}{\large\epsilon}))$</span><span> gates from a finite set. The value </span><span class='math-in-toc'>$c$</span><span> is a small constant, roughly 2. The minimum possible value of </span><span class='math-in-toc'>$c$</span><span> has not been proven. The value </span><span class='math-in-toc'>$0&lt;\epsilon&lt;1$</span><span> represents how accurate the approximation is. Since our rotation gates take the </span><span class='math-in-toc'>$\Delta$</span><span> parameter, any set containing the rotation gate will be infinite. An example of a finite set would be </span><span class='math-in-toc'>$\{\sqrt{X},\sqrt{Y},T\}$</span><span> where the </span><span class='math-in-toc'>$\Delta$</span><span> parameter is constant for every gate in the set. The only requirement for the finite set is that it must </span><em><span>fill</span></em><span> </span><span class='math-in-toc'>$P^1$</span><span>. </span></p><p><span>If a finite set of gates </span><span class='math-in-toc'>$S$</span><span> fills </span><span class='math-in-toc'>$P^1$</span><span>, then for every pair of quantum states, there must exist some sequence of gates </span><span class='math-in-toc'>$U_1, U_2,...,U_n \in S$</span><span> which links them.</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n274" cid="n274" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">S\text{ fills }P^1 \leftrightarrow \forall|\psi\rangle\ \forall|\psi'\rangle\ \exists(U_1, U_2, ...,U_n)\in S\quad U_n\cdots U_2U_1|\psi\rangle=|\psi'\rangle</script></div></div><p><span>The elements of the sequence do not need to be unique. This requirement of a filling set is not satisfied by all sets of gates. For example the set </span><span class='math-in-toc'>$\{X^{0.1}\}$</span><span> does not fill </span><span class='math-in-toc'>$P^1$</span><span>. In fact, no value of </span><span class='math-in-toc'>$\Delta$</span><span> on a single axis will produce a filling set. This is because some quantum state </span><span class='math-in-toc'>$|\psi\rangle$</span><span> will never be able to leave the ring generated by </span><span class='math-in-toc'>$\text{span}(X)$</span><span>, so there are states which cannot be accessed. </span></p><p><span>Another example of a non-filling set is </span><span class='math-in-toc'>$\{\sqrt{X}, \sqrt{Y},\sqrt{Z}\}$</span><span>. This one is slightly deceptive because for some generic state </span><span class='math-in-toc'>$|\psi\rangle$</span><span>, it appears to fill </span><span class='math-in-toc'>$P^1$</span><span>. However, consider the state </span><span class='math-in-toc'>$|0\rangle$</span><span>. There are only 6 states which are accessible: two states for each axis where the axis intersects the Bloch sphere. Conversely, it is also impossible to transform a generic state </span><span class='math-in-toc'>$|\psi\rangle$</span><span> into </span><span class='math-in-toc'>$|0\rangle$</span><span>. Since there exists a state which cannot access every other state, this set does not fill </span><span class='math-in-toc'>$P^1$</span><span>. </span></p><p><span>Checking if a set fills </span><span class='math-in-toc'>$P^1$</span><span> can be reduced to a graph problem. Suppose there is an infinite graph with one vertex per quantum state, and each vertex as </span><span class='math-in-toc'>$n$</span><span> edges, one for each gate in the set. A vertex may have a loop, where an edge connects the vertex to itself. If the graph has two or more </span><em><span>isolated subgraphs</span></em><span>, then the set does not fill </span><span class='math-in-toc'>$P^1$</span><span>. Isolated subgraphs, also called </span><em><span>components</span></em><span>, are a collection of vertices which cannot be connected to the rest of the graph.</span></p><p><span>This theorem is very important because it allows us to create arbitrary rotations out of a finite set of gates, and do it efficiently. Physical implementations of quantum computers may only be able to use certain fixed gates due to the immense engineering challenges present in building the hardware. Certain methods of error correction do not work for the continuous rotation gates, so approximating them from a finite set is required.</span></p><h3><a name="33qcsg---alternate-axes" class="md-header-anchor"></a><a href='#qcsg'><span>3.3</span></a><span>   Alternate Axes</span></h3><p><span>We have discussed rotating around the three major axes: X, Y, and Z. However, there is no reason why we can&#39;t rotate around other axes. A </span><em><span>minor axis</span></em><span> is a line defined by the origin and a single point. Technically, the data representing an axis is the same as the quantum state, since it is just a vector. For example, consider the </span><span class='math-in-toc'>$W$</span><span> axis which is defined to be </span><span class='math-in-toc'>$(X+Y)/\sqrt2$</span><span>. This is a unit vector which lies in the </span><span class='math-in-toc'>$XY$</span><span> plane, it represents the line where </span><span class='math-in-toc'>$X=Y$</span><span>. Just like the major axis rotations, there is also a matrix for rotating around the </span><span class='math-in-toc'>$W$</span><span> axis:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n281" cid="n281" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">W^\Delta= \begin{bmatrix}
\cos(\frac{\Delta\pi}{2}) & -\frac{1}{\sqrt2}\sin(\frac{\Delta\pi}{2})(1+i) \\
\frac{1}{\sqrt2}\sin(\frac{\Delta\pi}{2})(1-i) & \cos(\frac{\Delta\pi}{2})
\end{bmatrix}</script></div></div><p><span>The matrix for when </span><span class='math-in-toc'>$\Delta=0.5$</span><span> is:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n283" cid="n283" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\sqrt{W}=\begin{bmatrix} 
\frac{1}{\sqrt2} & -\frac{1}{2}-\frac{1}{2}i \\
\frac{1}{2}-\frac{1}{2}i & \frac{1}{\sqrt2}
\end{bmatrix}
=
\frac{1}{\sqrt2}
\begin{bmatrix} 
1 & -\sqrt{i} \\
\sqrt{-i} & 1
\end{bmatrix}</script></div></div><p><span>Although the </span><span class='math-in-toc'>$W$</span><span> axis is not frequently seen in quantum computing literature, it provides a nice example of a minor axis rotation matrix. </span></p><h4><a name="the-hadamard-axis" class="md-header-anchor"></a><span>The Hadamard Axis</span></h4><p><span>The </span><strong><span>Hadamard Gate</span></strong><span>, denoted </span><span class='math-in-toc'>$H$</span><span>, is one of the most common gates used in quantum computing, and it performs the following operation:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n287" cid="n287" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">H|0\rangle=\frac{1}{\sqrt2}(|0\rangle+|1\rangle) \\
H|1\rangle=\frac{1}{\sqrt2}(|0\rangle-|1\rangle)</script></div></div><p><span>The Hadamard gate is synonymous with generating superposition because it transforms both basis states into equal superposition. The state </span><span class='math-in-toc'>$|0\rangle$</span><span> is mapped to the positive X axis and the state </span><span class='math-in-toc'>$|1\rangle$</span><span> is mapped to the negative X axis. This operation is exactly what is performed by </span><em><span>beam splitters</span></em><span>. A beam splitter is a half-silvered mirror which will split an incoming stream of photons, reflecting one stream and letting the other stream pass through. </span></p><p><img src="../resources/img/3.3_beam_splitter.png" width="600px" /></p><center><i>Figure 3.3.1 - Beam Splitter Diagram</i></center><p><span>In the above diagram, the beam of light is coming from the left and splits into two separate beams. The half-silvered mirror is placed diagonally in the box. We can place two beam splitters and two mirrors in a configuration called a </span><strong><span>Mach-Zender Interferometer</span></strong><span> and add detectors for each of the projected output beams.</span></p><p><img src="../resources/img/3.3_mach_zender.png" width="732px" /></p><center><i>Figure 3.3.2 - Mach-Zender Interferometer</i></center><p><span>Using the configuration of beam splitters and mirrors described above, say we produce 100 photons. How many of those photons will be detected by B?</span></p><p><span>The answer is zero. All of the photons will be detected by A, the detector at B will never see a photon. This result seems unintuitive, if a beam splitter splits a stream of photons, why doesn&#39;t the second half-silvered mirror split both streams again? This is because </span><span class='math-in-toc'>$H^2=I$</span><span>. In this experiment, the photon acted as a qubit, initialized to the state </span><span class='math-in-toc'>$|0\rangle$</span><span>. After passing through the first beam splitter, the qubit entered superposition, but came back out of superposition after the second beam splitter. The Hadamard gate&#39;s matrix representation is:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n296" cid="n296" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">H=\begin{bmatrix}
\frac{1}{\sqrt2} & \frac{1}{\sqrt2} \\
\frac{1}{\sqrt2} & -\frac{1}{\sqrt2}
\end{bmatrix}
\\ \ \\ \ \\
HH|0\rangle=|0\rangle</script></div></div><p><span>The </span><span class='math-in-toc'>$H$</span><span> gate can be decomposed into </span><span class='math-in-toc'>$H=\sqrt{Y}Z=X\sqrt{Y}$</span><span>. Specifically, the Hadamard gate is a rotation of </span><span class='math-in-toc'>$\Delta=1$</span><span> around the Hadamard axis, </span><span class='math-in-toc'>$H=(X+Z)/\sqrt2$</span><span>. The </span><span class='math-in-toc'>$H$</span><span> axis is a line in the </span><span class='math-in-toc'>$XZ$</span><span> plane where </span><span class='math-in-toc'>$X=Z$</span><span>. Just like the </span><span class='math-in-toc'>$W$</span><span> axis, there is a matrix which generalizes a rotation of any amount:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n298" cid="n298" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">H^\Delta=
\begin{bmatrix}
\cos(\frac{\Delta\pi}{2})-\frac{i}{\sqrt2}\sin(\frac{\Delta\pi}{2}) & -\frac{i}{\sqrt2}\sin(\frac{\Delta\pi}{2}) \\
-\frac{i}{\sqrt2}\sin(\frac{\Delta\pi}{2}) & \cos(\frac{\Delta\pi}{2})+\frac{i}{\sqrt2}\sin(\frac{\Delta\pi}{2})
\end{bmatrix}</script></div></div><p><span>These beam splitters are more than neat party tricks. Using the </span><strong><span>KLM Protocol</span></strong><span>, it is possible to create universal quantum computers using just mirrors, half-silvered mirrors, and phase shifters. </span></p><h4><a name="arbitrary-axes" class="md-header-anchor"></a><span>Arbitrary Axes</span></h4><p><span>The next step is to rotate our quantum state around any arbitrary axis. This is an applet which shows the accessible state space of rotating the state around any axis. The sliders on the left change the </span><span class='math-in-toc'>$\theta$</span><span> and </span><span class='math-in-toc'>$\phi$</span><span> of the quantum state and the sliders on the right change the </span><span class='math-in-toc'>$\theta$</span><span> and </span><span class='math-in-toc'>$\phi$</span><span> of the axis. The axis is set to the Hadamard axis by default.</span></p><iframe height="500" scrolling="no" title="Arbitrary Axis Rotation Applet" src="..\resources\applets\arbitrary_axis\index.html" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%; user-select:none;">Arbitrary Axis Rotation Applet</iframe><center><i><a href="../resources/applets/arbitrary_axis/index.html" target="_blank">Applet 3.3.3</a> Arbitrary Axis Rotations Applet</i></center><p><span>The matrix for rotating around any axis </span><span class='math-in-toc'>$\hat n$</span><span> can be written as the sum of the identity matrix and the Pauli matrices:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n305" cid="n305" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\hat n^\Delta = \cos(\frac{\Delta\pi}{2})I-i \sin(\frac{\Delta\pi}{2})(n_xX+n_yY+n_zZ)</script></div></div><p><span>This is the equation used to derive the rotation around the </span><span class='math-in-toc'>$W$</span><span> and </span><span class='math-in-toc'>$H$</span><span> axes described above. Alternatively, the same matrix can be written as the product of the </span><span class='math-in-toc'>$Y$</span><span> and </span><span class='math-in-toc'>$Z$</span><span> rotation matrices:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n307" cid="n307" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">a = \frac{n_\phi}{\pi} \\
b = \frac{n_\theta}{\pi} \\
\hat n^\Delta=Z^{\large a} Y^{\large b} Z^\Delta Y^{\large -b} Z^{\large -a}</script></div></div><p><span>Note how the sum equation uses the axis&#39; Euclidean coordinates and the product equation uses the axis&#39; spherical coordinates.</span></p><p><span>Since a quantum state is mathematically equivalent to a vector, that implies we could use a quantum state as an axis to rotate around. For example, rotating around itself is always an identity operation:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n310" cid="n310" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\psi^\Delta|\psi\rangle=I</script></div></div><p><span>However, we don&#39;t actually know the </span><span class='math-in-toc'>$\theta$</span><span> and </span><span class='math-in-toc'>$\phi$</span><span> of some generic quantum state. To rotate around an axis, the coordinates of the axis must be known, otherwise how would we know which gates to apply?</span></p><h3><a name="34qcsg---quantum-registers" class="md-header-anchor"></a><a href='#qcsg'><span>3.4</span></a><span>   Quantum Registers</span></h3><p><span>Up to this point, we have used the term </span><em><span>quantum system</span></em><span> interchangeably with the term </span><em><span>qubit</span></em><span> because we have only focused on a single qubit. However, a quantum system is a more general concept, it refers to all quantum objects of interest to us in a particular setting. When we have collection of qubits, it is called a </span><em><span>quantum register</span></em><span> and they are grouped together under one quantum system. </span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n314" cid="n314" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|\psi\rangle=\frac{1}{2}(|00\rangle+|01\rangle+|10\rangle+|11\rang)</script></div></div><p><span>Above is an example of a two qubit quantum system in equal superposition. The </span><span class='math-in-toc'>$|\psi\rangle$</span><span> is still used to describe the entire quantum register, although now there are more </span><em><span>basis states</span></em><span>. Rather than just having </span><span class='math-in-toc'>$|0\rangle$</span><span> and </span><span class='math-in-toc'>$|1\rangle$</span><span>, there are now four basis states to describe every possible combination of states the qubits could collapse into. Each basis state also has a complex coefficient assigned to it, the probability of the quantum system collapsing into a particular basis state </span><span class='math-in-toc'>$i$</span><span> can be found: </span><span class='math-in-toc'>$P(|\psi\rangle=|i\rangle)=|c_i|^2$</span><span>. In general, a quantum register of </span><span class='math-in-toc'>$n$</span><span> qubits can be described in ket notation:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n316" cid="n316" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|\psi\rangle=\sum_{i=0}^{2^n} c_i|i\rangle \\
\text{where } \sum_{i=0}^{2^n}|c_i|^2=1</script></div></div><p><span>Suppose we are given two separate qubits, how do we create our quantum system to describe both of them?</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n318" cid="n318" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{equation}\begin{aligned}
|\psi_0\rangle&=\alpha_0|0\rangle+\beta_0|1\rangle \\
|\psi_1\rangle&=\alpha_1|0\rangle+\beta_1|1\rangle \\
\end{aligned} \\ \ \\
\begin{aligned}
|\psi\rangle=|\psi_1\rangle|\psi_0\rangle&= (\alpha_1|0\rangle+\beta_1|1\rangle)\otimes (\alpha_0|0\rangle+\beta_0|1\rangle) \\

&= \alpha_1\alpha_0|0\rangle|0\rangle+\alpha_1\beta_0|0\rangle|1\rangle+\beta_1\alpha_0|1\rangle|0\rangle+\beta_1\beta_0|1\rangle|1\rangle
\\
&= \alpha_1\alpha_0|00\rangle+\alpha_1\beta_0|01\rangle+\beta_1\alpha_0|10\rangle+\beta_1\beta_0|11\rangle

\end{aligned}\end{equation}</script></div></div><p><span>The key to merging two separate qubits into one quantum system is the </span><em><span>tensor product</span></em><span>. This operation is denoted by the </span><span class='math-in-toc'>$\otimes$</span><span> symbol and it looks similar to distributing two binomials. There are different notations for the tensor product, but they all mean the same thing:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n320" cid="n320" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|\psi_1\rangle\otimes|\psi_0\rangle=|\psi_1\rangle|\psi_0\rangle=|\psi_1\psi_0\rangle</script></div></div><p><span>We have described how the tensor product works using the Dirac notation, but quantum states can also be described using vectors:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n322" cid="n322" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|\psi_1\rangle\otimes|\psi_0\rangle=
\begin{bmatrix}
\alpha_1 \\ \beta_1
\end{bmatrix} \otimes
\begin{bmatrix}
\alpha_0 \\ \beta_0
\end{bmatrix} =
\begin{bmatrix}
\alpha_1
\begin{bmatrix}
\alpha_0 \\ \beta_0
\end{bmatrix} \\ 
\beta_1
\begin{bmatrix}
\alpha_0 \\ \beta_0
\end{bmatrix}
\end{bmatrix} = 
\begin{bmatrix}
\alpha_1\alpha_0 \\
\alpha_1\beta_0\\
\beta_1\alpha_0\\
\beta_1\beta_0
\end{bmatrix}</script></div></div><p><span>In general, a tensor product between a vector with </span><span class='math-in-toc'>$n$</span><span> rows and another vector with </span><span class='math-in-toc'>$m$</span><span> rows produces a vector with </span><span class='math-in-toc'>$nm$</span><span> rows. The tensor product is associative, but it is not communitive, so </span><span class='math-in-toc'>$|\psi_0\psi_1\rangle\neq|\psi_1\psi_0\rangle$</span><span>. For this reason, we need to be clear about the ordering of the qubits. The standard convention is to have the rightmost qubit be the least significant bit. This means the state </span><span class='math-in-toc'>$|100\rangle$</span><span> will represent the number 4 instead of the number 1. Since the quantum state is being created from an array of qubits, the indexes follow zero-based numbering. The least significant qubit is described as the zeroth qubit in the register. </span></p><p><span>Here is an algorithm which will create the amplitude at index </span><span class='math-in-toc'>$row$</span><span> after the tensor product of </span><span class='math-in-toc'>$n$</span><span> qubits:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="python"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">def</span> <span class="cm-def">create_amplitude</span>(<span class="cm-variable">row_index</span>, <span class="cm-variable">qubits</span>):</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">amplitude</span> = <span class="cm-number">1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">for</span> <span class="cm-variable">i</span> <span class="cm-keyword">in</span> <span class="cm-variable">n</span>:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  <span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">if</span> ((<span class="cm-variable">row_index</span> <span class="cm-operator">&amp;</span> <span class="cm-number">1</span> <span class="cm-operator">&lt;&lt;</span> <span class="cm-variable">i</span>) == <span class="cm-number">0</span>):</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  <span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">amplitude</span> *= <span class="cm-variable">qubits</span>[<span class="cm-variable">i</span>].<span class="cm-property">alpha</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">else</span>:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  <span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">amplitude</span> *= <span class="cm-variable">qubits</span>[<span class="cm-variable">i</span>].<span class="cm-property">beta</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">return</span> <span class="cm-variable">amplitude</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 184px;"></div><div class="CodeMirror-gutters" style="display: none; height: 184px;"></div></div></div></pre><p><span>Consider the index </span><span class='math-in-toc'>$01001$</span><span> in a 5 qubit register. The amplitude at this position is </span><span class='math-in-toc'>$\alpha_4\beta_3\alpha_2\alpha_1\beta_0$</span><span>. Each </span><span class='math-in-toc'>$0$</span><span> in the index corresponds to the amplitude being multiplied by that qubit&#39;s </span><span class='math-in-toc'>$\alpha$</span><span> component and each </span><span class='math-in-toc'>$1$</span><span> means the amplitude is multiplied by that qubit&#39;s </span><span class='math-in-toc'>$\beta$</span><span> component.</span></p><p><span>The algorithm above iterates through each bit in the index and multiplies the amplitude by the corresponding component depending if the bit is </span><span class='math-in-toc'>$0$</span><span> or </span><span class='math-in-toc'>$1$</span><span>. This algorithm uses </span><em><span>bitwise operators</span></em><span> to determine the state of a bit inside the index. The following bitwise operators are frequently used:</span></p><ul><li><code>&amp;</code><span> - Bitwise AND</span></li><li><code>|</code><span> - Bitwise OR</span></li><li><code>^</code><span> - Bitwise XOR</span></li><li><code>&lt;&lt;</code><span> - Bitwise left shift </span></li><li><code>&gt;&gt;</code><span> - Bitwise right shift</span></li></ul><h4><a name="quantum-circuits" class="md-header-anchor"></a><span>Quantum Circuits</span></h4><p><span>When describing which gates are being applied to which qubits, using the Dirac notation can become cluttered. </span><em><span>Quantum circuits</span></em><span> are a visual way to show the ordering of the gates. Below is an applet to show a simple quantum circuit with 2 qubits and an X, Y, and Z rotation gate on each. </span></p><iframe height="300" scrolling="no" title="Simple Quantum Circuit Applet" src="..\resources\applets\simple_circuit\index.html" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%; user-select:none;">Simple Quantum Circuit Applet</iframe><center><i><a href="../resources/applets/simple_circuit/index.html" target="_blank">Applet 3.4.1</a> Simple Quantum Circuit Applet</i></center><p><span>Starting from the left, first there are the inputs to the quantum circuit. Typically, a quantum circuit is initialized with </span><span class='math-in-toc'>$|0\rangle$</span><span> for each qubit, but sometimes a generic state </span><span class='math-in-toc'>$|\psi\rangle$</span><span> is the input when comparing multiple circuits. The top qubit is the least significant qubit which corresponds to the rightmost qubit in the  Dirac notation.</span></p><p><span>Next are all of the gates in the circuit. Each wire runs horizontally and contains a sequence of gates which are applied to the qubit. Unlike the matrix form of gates, the gates in a circuit are read left-to-right. In our simple circuit, the X gate is applied first, followed by the Y gate and then the Z gate. For this example, each gate has a slider which controls the </span><span class='math-in-toc'>$\Delta$</span><span> parameter of that gate.</span></p><p><span>The square on the right side is a visual representation of the quantum state. Each sub-box represents a basis state, the size of the circle represents the magnitude and the orientation of the circle represents the phase. The global phase is automatically adjusted so the </span><span class='math-in-toc'>$|0\rangle$</span><span> state remains real. </span></p><p><span>This example is just a simple quantum circuit for demonstration purposes. A more advanced quantum circuit builder is available through </span><a href="https://algassert.com/quirk" target="_blank"><span>Quirk</span></a><span>. </span></p><h4><a name="matrix-tensor-product" class="md-header-anchor"></a><span>Matrix Tensor Product</span></h4><p><span>A 2-qubit quantum system can be created by using the tensor product on two vectors. How do we apply a gate to this larger vector? Our </span><span class='math-in-toc'>$2\times2$</span><span> matrices cannot be directly applied to a vector with </span><span class='math-in-toc'>$4$</span><span> rows, there would be a dimension mismatch. The key is to use the tensor product on the gate as well!</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n349" cid="n349" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|\psi_1\rangle\otimes H|\psi_0\rangle=(I\otimes H)|\psi_1\psi_0\rangle</script></div></div><p><span> If we would like to apply a Hadamard gate on the right qubit and nothing on the left qubit, it is the tensor product between the </span><span class='math-in-toc'>$H$</span><span> and </span><span class='math-in-toc'>$I$</span><span> matrices. In general, a tensor product between two matrices takes the form:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n351" cid="n351" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{bmatrix}
a & b \\ c & d
\end{bmatrix} \otimes
\begin{bmatrix}
e & f \\ g & h
\end{bmatrix} = 
\begin{bmatrix}
a
\begin{bmatrix}
e & f \\ g & h
\end{bmatrix} & 
b
\begin{bmatrix}
e & f \\ g & h
\end{bmatrix} \\
c
\begin{bmatrix}
e & f \\ g & h
\end{bmatrix} & 
d
\begin{bmatrix}
e & f \\ g & h
\end{bmatrix}
\end{bmatrix} = 
\begin{bmatrix}
ae & af & be & bf \\
ag & ah & bg & bh \\
ce & cf & de & df \\
cg & ch & dg & dh
\end{bmatrix}</script></div></div><p><span>The tensor product for matrices is still non-communitive. In order to apply a </span><span class='math-in-toc'>$2\times2$</span><span> gate to the </span><span class='math-in-toc'>$i$</span><span>th qubit, there must be </span><span class='math-in-toc'>$n$</span><span> matrices tensored together:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n353" cid="n353" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|\psi_{n-1}\cdots\psi_{i+1}\rangle\otimes U|\psi_i\rangle\otimes |\psi_{i-1}\cdots\psi_0\rangle = 
\bigg( \bigotimes_{j=i+1}^nI \bigg) \otimes U \otimes \bigg(\bigotimes_{j=0}^i I \bigg) |\psi\rangle</script></div></div><p><span>When applying just one </span><span class='math-in-toc'>$2 \times 2$</span><span> gate to a quantum register, it gets tensored with </span><span class='math-in-toc'>$n-1$</span><span> identity matrices. This fact highlights an interesting characteristic of the tensor product. Say we would like to apply two </span><span class='math-in-toc'>$2\times 2$</span><span> gates on a 2 qubit system, </span><span class='math-in-toc'>$U_0$</span><span> and </span><span class='math-in-toc'>$U_1$</span><span>. We could tensor the gates together like shown with the general form of the tensor product, but we could also tensor each gate with the identity matrix like shown with the </span><span class='math-in-toc'>$i$</span><span>th qubit form and then multiply:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n355" cid="n355" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">U_1 \otimes U_0=(U_1\otimes I)(I \otimes U_0)=(I\otimes U_0)(U_1\otimes I)</script></div></div><p><span>Tensoring each matrix with the identity matrix and them multiplying them together is equivalent to tensoring the matrices together directly. Furthermore, the matrix multiplication of </span><span class='math-in-toc'>$U_1\otimes I$</span><span> and </span><span class='math-in-toc'>$I\otimes U_0$</span><span> is communitive! This can be generalized to any number of gates acting on a quantum register, the matrix multiplication between all of these identity-tensored gates is communitive.</span></p><h3><a name="35qcsg---controlled-gates" class="md-header-anchor"></a><a href='#qcsg'><span>3.5</span></a><span>   Controlled Gates</span></h3><p><span>The goal of this section is to address how qubits interact with each other. So far, we have treated qubits as separate entities which can be operated on independently. To create a powerful model of computation, qubit states need to be able to impact each other. In quantum computing, we use transformations called </span><em><span>controlled operations</span></em><span> which are able to connect qubits.</span></p><h4><a name="controlled-not-gate" class="md-header-anchor"></a><span>Controlled Not Gate</span></h4><p><span>The most fundamental controlled gate is called the </span><em><span>controlled not</span></em><span> and it takes in 2 qubits: a control qubit and a target qubit. In English, the transformation a controlled not (CNOT) gate performs is described as: </span><em><span>if the control qubit is</span></em><span> </span><span class='math-in-toc'>$|1\rangle$</span><span>, </span><em><span>then flip the target qubit</span></em><span>. We can create a truth table which describes the operation if the left qubit is the control and the right qubit is the target</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n361" cid="n361" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{equation}\begin{aligned}
|c\ t\rangle& \\
|00\rangle&\rightarrow|00\rangle \\
|01\rangle&\rightarrow|01\rangle \\
|10\rangle&\rightarrow|11\rangle \\
|11\rangle&\rightarrow|10\rangle
\end{aligned}\end{equation}</script></div></div><p><span>The above ket notation shows a truth table for every basis state. If the control qubit is </span><span class='math-in-toc'>$|0\rangle$</span><span>, the CNOT acts as an identity operation and nothing happens. If the control qubit is </span><span class='math-in-toc'>$|1\rangle$</span><span>, the target qubit is flipped. The same operation can be visualized in the tensored vector form:</span></p><p><img src="../resources/img/3.5_cnot_vector_switch.png" /></p><p><span>The CNOT transformation switches the placement of the </span><span class='math-in-toc'>$|10\rangle$</span><span> and </span><span class='math-in-toc'>$|11\rangle$</span><span> coefficients. The CNOT gate is also called the CX gate since it is essentially a controlled X rotation. The matrix form of the CNOT gate is written as:</span></p><p><img src="../resources/img/3.5_cnot_matrix.png" /></p><p><span>Notice how the transformation the CNOT applies changes depending which qubit is acting as the control. In circuit form, the small black dot denotes the control qubit and the large </span><span class='math-in-toc'>$\oplus$</span><span> shows the target qubit. Remember that we are using the standard where the topmost qubit line is the least significant qubit. The truth table and the tensored vector descriptions are referring to the top circuit where the control qubit is below the target qubit. Some sources use a different standard where the bottom-most qubit is the least significant qubit, which would switch the matrix-circuit representations.</span></p><p><span>The control and target qubits cannot be the same qubit in a CNOT gate. Such an operation would create the following truth table, which is not reversible:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n368" cid="n368" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|0\rangle\rightarrow|0\rangle \\
|1\rangle\rightarrow|0\rangle \\
\text{Not a reversible operation!}</script></div></div><p><span>One question students often ask is &quot;why use the </span><span class='math-in-toc'>$\oplus$</span><span> symbol for the CNOT gate?&quot; In computational logic, the </span><span class='math-in-toc'>$\oplus$</span><span> symbol refers to the exclusive or (XOR) of two bits. The controlled-not gate is a reversible version of XOR, the control qubit is unaffected and the target qubit becomes the XOR of the control and the target:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n370" cid="n370" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">|c\rangle|t\rangle\rightarrow|c\rangle|c\oplus t\rangle</script></div></div><h4><a name="swap-gate" class="md-header-anchor"></a><span>SWAP Gate</span></h4><p><span>An interesting property of the XOR operation is that it can swap the values of two variables without using a temporary variable. Consider the binary variables </span><span class='math-in-toc'>$X$</span><span> and </span><span class='math-in-toc'>$Y$</span><span> and perform the following algorithm on them:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n373" cid="n373" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">X := X\oplus Y \\
Y := Y\oplus X \\
X := X\oplus Y</script></div></div><p><span>After 3 XORs, the variable </span><span class='math-in-toc'>$X$</span><span> will contain the original value of </span><span class='math-in-toc'>$Y$</span><span> and vice versa. As we have already discussed, the CNOT gate is the reversible equivalent to the XOR gate, which means we can create a SWAP gate out of 3 CNOT gates:</span></p><p><img src="../resources/img/3.5_swap_circuit.png" width="850px" /></p><p><span>This gate switches the incoming qubit states so the bottom qubit now contains the original state of the top qubit and vice versa. The SWAP gate is symmetric with respect to the qubits it is swapping. That is to say, </span><span class='math-in-toc'>$\text{SWAP}(|\psi\rangle,|\varphi\rangle)=\text{SWAP}(|\varphi\rangle,|\psi\rangle)$</span><span>. As expected, the SWAP gate is its own inverse, so two sequential SWAP gates is an identity operation. The matrix of the SWAP gate is:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n377" cid="n377" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\text{SWAP}=
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}</script></div></div><h4><a name="controlled-z-gate" class="md-header-anchor"></a><span>Controlled Z Gate</span></h4><p><span>Similar to how the CNOT gate is a controlled X rotation of </span><span class='math-in-toc'>$\Delta=1$</span><span>, we can also create the CZ gate for a controlled Z rotation. The CZ gate performs the following operation:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n380" cid="n380" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">\begin{matrix}
|c\ t\rangle\quad\   \\
|00\rangle\rightarrow&\ \ \ |00\rangle \\
|01\rangle\rightarrow&\ \ \ |01\rangle \\
|10\rangle\rightarrow&\ \ \ |10\rangle \\
|11\rangle\rightarrow&-|11\rangle
\end{matrix}</script></div></div><p><span>The controlled Z gate applies a phase shift only when both qubits are in the state </span><span class='math-in-toc'>$|11\rangle$</span><span>. This operation is symmetric with respect to the input qubits:</span></p><p><img src="../resources/img/3.5_cz_circuit.png" width="450px" /></p><p><span>Since the orientation of the CZ gate doesn&#39;t matter, another common notation for the gate is to have control dots on both qubits. The matrix representation of the gate is:</span></p><p><img src="../resources/img/3.5_cz_matrix.png"  width="350px"/></p><p><span>A CZ gate can be constructed using a CNOT gate and 2 Hadamard gates like so:</span></p><p><img src="../resources/img/3.5_cx_cz_equal.png" width="550px"/></p><p><span>Using the above relationship, we can flip the CZ gate since it is symmetric and create a method to flip the CNOT gate using Hadamard gates.</span></p><p><img src="../resources/img/3.5_cx_flip.png" width="550px"/></p><p><span>The controlled Z gate has applications in simulating quantum circuits on quantum computers. The runtime of simulating a CZ gate is faster than a CNOT gate, so if a circuit can be transformed into an equivalent circuit using approximately the same number of gates, the simulation will be noticeably faster.</span></p><h4><a name="controlled-u-gate" class="md-header-anchor"></a><span>Controlled U Gate</span></h4><p><span>The controlled X and controlled Z gates are specific instances of the general controlled U gate. Any single qubit gate </span><span class='math-in-toc'>$U$</span><span> can be transformed into a CU gate:</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n392" cid="n392" mdtype="math_block"><div class="md-rawblock-container md-math-container" tabindex="-1"><script type="math/tex; mode=display">U=\begin{bmatrix}
u_{00} & u_{01} \\
u_{10} & u_{11}
\end{bmatrix}</script></div></div><p><img src="../resources/img/3.5_cu_matrix.png"/></p><p><span>Every 2 qubit gate described above has acted on adjacent qubits inside the circuit. It is also possible to have the control further away and &quot;jump over&quot; qubits to reach the target. The CU gate does not impact the two qubits which do not have a control or gate placed on them. However, what if we have a constraint on our circuit that all 2 qubit gates must act on adjacent qubits? This can be overcome by simply using SWAP gates to pull the control closer:</span></p><p><img src="../resources/img/3.5_cu_space.png" width="600px"/></p><p><span>This idea can be extended for any number of intermediate qubits by increasing the staircase of SWAP gates. Engineering physical quantum computers is already a challenging task, creating controlled gates between any pair of arbitrary qubits in the circuit may be infeasible. As a result, this trick can be used so engineers only need to implement controlled operations between adjacent qubits in the circuit. </span></p><h4><a name="circuit-specifications" class="md-header-anchor"></a><span>Circuit Specifications</span></h4><p><span>In the above CU circuit, originally there weren&#39;t any gates on the middle two qubits. However, there are several gates acting on them after the transformation. In this circuit, the middle two qubits are acting as </span><em><span>ancilla qubits</span></em><span>. An ancilla qubit is a qubit which has operations performed on it that do not directly contribute to the result, but help indirectly. They typically come in two flavors: identity ancilla qubits and garbage ancilla qubits. </span></p><p><span>The ancilla qubits in the CU circuit are acting as identity ancilla qubits because even though there are gates being applied to them, the end result is equivalent to the identity operation. These identity ancilla qubits were borrowed to accomplish a more complicated goal, but had the affects undone after the goal was accomplished. Garbage ancilla qubits do not have such restrictions, the results after measuring a garbage ancilla qubit are discarded. Garbage ancilla qubits are particularly useful in quantum computation for reducing the </span><em><span>depth</span></em><span> of a circuit. </span></p><p><span>The depth of a circuit refers to how long it takes to run. This is measured by the number of </span><em><span>timesteps</span></em><span> a circuit has. In one timestep, several gates can be applied to the quantum register, but two gates cannot be applied to the same qubit in a single timestep. Many quantum circuits are extremely parallelizable since multiple gates are applied in sync. The depth of a circuit can change after a quantum complier changes the circuit to fit the architecture of the computer. For example, if our quantum computer can only apply two qubit gates to adjacent qubits, the CU circuit above transforms from having a depth of 1 to a depth of 5. This is similar to how classical programs change length after being compiled for a target machine. Typically, the actual depth of a quantum circuit is not used, just the asymptotic gate depth. It is expressed using big-oh notation as a function of the input. For example, linear gate depth would be </span><span class='math-in-toc'>$O(n)$</span><span>. </span></p><h3><a name="36qcsg---quantum-programming" class="md-header-anchor"></a><a href='#qcsg'><span>3.6</span></a><span>   Quantum Programming</span></h3><p><span>After discussing the operations a quantum computer can perform to its qubits, how would we program a quantum computer? To date, a high-level quantum programming language has not yet been developed so modern quantum computers are coded with individual gates, similar to assembly for classical computers. There aren&#39;t even any independent quantum languages, most of the &quot;languages&quot; are just libraries accessed from classical languages.</span></p><p><span>Modern quantum programming workflow first creates a desired circuit in a quantum programming library on a classical computer. Then that circuit is sent to either a quantum computer or a quantum simulator to run. After, the result of the computation is returned to the user, typically as a histogram of measurement results. This histogram is now considered classical data and the user can use it as they please. </span></p><p><img src="../resources/img/3.7_workflow.png"/></p><center><i>Figure 3.6.1 - Modern Quantum Programming Workflow</i></center><p><span>The compilers are a very important step in this process which often get overlooked. Just like classical compilers, a quantum compiler takes in some general circuit and changes the gates to run most effectively on the target platform. The platform can be a specific architecture or simulator type which handles certain types of circuits better than others.</span></p><p><span>There are many libraries used for creating quantum circuits, most companies have developed their own so it is likely there won&#39;t be a standard one until quantum computers become more ubiquitous. </span></p><h4><a name="qiskit" class="md-header-anchor"></a><span>Qiskit</span></h4><p><span>Released in March of 2017, Qiskit is IBM&#39;s quantum computing framework for Python. Users can create circuits and use a range of tools examine them. Qiskit comes with four components: Terra, Aer, Aqua, and Ignis. Terra is element used to build circuits and send them to a real quantum computer over the cloud. Aer is a quantum simulator which can model a perfect or imperfect quantum computer. Aqua is a package of premade algorithms usable without understanding of quantum computing. Ignis is a collection of tools for understanding noise. Qiskit is the most used framework among the quantum computing community and is the one used in this document for describing circuits with code.</span></p><h4><a name="q" class="md-header-anchor"></a><span>Q#</span></h4><p><span>Released in December of 2017, Qsharp is Microsoft&#39;s quantum computing framework for C#. Currently, Q# is just a quantum simulator capable of processing up to 32 qubits on a local machine and up to 40 on Microsoft Azure, their cloud computing service. The community surrounding Q# expects Microsoft to eventually offer a hardware service similar to Qiskit using </span><em><span>topological qubits</span></em><span>. Topological qubits are a currently theoretical implementation of a qubit which is still under development.</span></p><h4><a name="cirq" class="md-header-anchor"></a><span>Cirq</span></h4><p><span>Released in July of 2018, Cirq is Google&#39;s quantum computing framework for Python. Similar to Q#, Cirq is just a quantum simulator with no currently announced plans of offering a physical backend to run circuits. Cirq has close ties with Google&#39;s OpenFermion project which uses quantum algorithms to simulate fermionic systems like quantum chemistry. </span></p><h3><a name="37qcsg---case-study-googles-quantum-supremacy" class="md-header-anchor"></a><a href='#qcsg'><span>3.7</span></a><span>   Case Study: Google&#39;s Quantum Supremacy</span></h3><p><span>In late 2019, Google announced they had achieved </span><em><span>quantum supremacy</span></em><span> on their 53 qubit quantum processor named Sycamore, published in </span><a href="https://www.nature.com/articles/s41586-019-1666-5" target="_blank"><span>Nature</span></a><span>. Quantum supremacy is the term for when a quantum program can beat a classical program at a task. What kind of task? It doesn&#39;t matter. There is no official benchmark, so the task can be any type of algorithm or can simply have a useless objective. As long as the QPU is significantly faster than a classical computer at </span><strong><span>any</span></strong><span> objective, quantum supremacy is declared.</span></p><p><span>What task did Google use to have their quantum computer compete in? Simulating a quantum computer. Sycamore is a quantum computer, so the simulation is just running a quantum circuit. So as long as the quantum computer can run faster than a classical computer can simulate it, the quantum computer wins. This may appear rather silly since there isn&#39;t really any objective to the computation, but that is actually why it is clever. If there was an objective to compute then there would be alternative methods for a classical programmer or patterns to exploit to make the classical program faster. </span></p><p><span>Specifically, Google called this task </span><em><span>random circuit sampling</span></em><span>. Every quantum circuit creates a probability distribution, so the objective was to find the probability distribution of a randomly generated circuit. A random circuit does not have any patterns for a classical programmer to use for time or memory exploitations. However, not all quantum circuits take the same amount of time to simulate. The hardest circuits for a classical simulator are random and all the qubits are highly entangled (but not maximally entangled)! </span></p><p><span>There are limitations on the quantum computer as well. The Sycamore processor is noisy, every gate applied causes small errors to build up and can lead to the wrong answers if too many gates are applied. So the ideal circuit should have the following properties:</span></p><ul><li><span>No observable patterns</span></li><li><span>Highly entangled</span></li><li><span>Small depth</span></li></ul><p><span>To create circuits that have all three properties, the Google quantum team used a pseudorandom generator which uses a seed to create circuits in this format:</span></p><p><img src="../resources/img/4.5_circuit.png" width="800px" /></p><p>&nbsp;</p><center><i>Figure 4.5.1 - Pseudorandom Circuit Architecture</i></center><p><span>The circuit is divided into </span><em><span>m</span></em><span> cycles in which every cycle has 1 single qubit gate applied per qubit followed a double qubit gate. The single qubit gates are chosen pseudo randomly and can be </span><span class='math-in-toc'>$\sqrt{X}$</span><span>, </span><span class='math-in-toc'>$\sqrt{Y}$</span><span>, or </span><span class='math-in-toc'>$\sqrt{W}$</span><span>. Two gates of the same axis cannot be chosen sequentially. The </span><span class='math-in-toc'>$\sqrt{W}$</span><span> gate is a rotation of </span><span class='math-in-toc'>$\frac{\pi}{2}$</span><span> radians around the axis </span><span class='math-in-toc'>$(X+Y)/\sqrt2$</span><span>. Similar to the Hadamard axis, this axis is formed by the line </span><span class='math-in-toc'>$X=Y$</span><span> when </span><span class='math-in-toc'>$Z=0$</span><span>. The double qubit gates are chosen from a set sequence: repeat </span><span class='math-in-toc'>$ABCDCDAB$</span><span>. The chosen letter represents the gate being applied to every pair of neighbor qubits connected by a colored coupler. </span></p><iframe height="500" scrolling="no" title="Sycamore Coupler Applet" src="..\resources\applets\sycamore_couplers\index.html" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%; user-select:none;">Sycanmore Couplet Applet</iframe><center><i><a href="../resources/applets/sycamore_couplers/index.html" target="_blank">Applet 4.5.2</a> Sycamore's QPU Architecture</i></center><p><span>To understand the double qubit gates better, we can look at Sycamore&#39;s qubit layout. In figure 4.5.2, the gray crosses represent qubits and the colored boxes are couplers which connect the qubits together. The outlined cross on the top row is a qubit which does not work which is why this QPU is only 53 qubits instead of the original 54. When a double qubit gate is chosen from the set, for example </span><span class='math-in-toc'>$A$</span><span>, all of the green couplers activate at the same time. So the double qubit layer in the circuit does not just refer to one pair of qubits; it refers to all pairs of qubits joined by a green coupler. Not every qubit is affected by the </span><span class='math-in-toc'>$A$</span><span> gate however, since the bottom row does not have any green couplers connecting to them.</span></p><h4><a name="quantum-vs-classical" class="md-header-anchor"></a><span>Quantum vs. Classical</span></h4><p><span>Every quantum circuit essentially creates a probability distribution, but the way a quantum computer finds this distribution is different than a classical computer. A quantum computer approximates the distribution by running the circuit many times and recording the result of each measurement. After taking a large number of samples, the sampled distribution is roughly equal to the real distribution. Google&#39;s team sampled their largest circuit 30 million times, taking around 100 minutes.</span></p><p><span>Google&#39;s team used a Schrödinger/Feynman hybrid algorithm to simulate a 43 qubit circuit on a classical computer. The Schrödinger algorithm stores all </span><span class='math-in-toc'>$2^n$</span><span> coefficients in memory and the Feynman algorithm calculates each coefficient independently which only requires a polynomial amount of memory, but requires exponentially more time proportional to the depth of the circuit. </span></p><p><span>In their paper, the team made the claim that using this hybrid algorithm to simulate the largest 53 qubit circuit would take 10,000 years on the world&#39;s best supercomputers, thus proving quantum supremacy. This time estimate was created by assuming the memory was constrained to Random Access Memory (RAM). Other experts did not agree with this assumption.</span></p><h4><a name="ibms-rebuttal" class="md-header-anchor"></a><span>IBM&#39;s Rebuttal</span></h4><p><span>The quantum computing team at IBM </span><a href="https://www.ibm.com/blogs/research/2019/10/on-quantum-supremacy/" target="_blank"><span>responded</span></a><span> to Google&#39;s claim to quantum supremacy by using a pure Schrödinger algorithm. They showed that it was possible to rotate the memory for the quantum state out to disk, only keeping the active parts in RAM. Every coefficient is 8 bytes since they are complex numbers, stored as two single precision floating point numbers. The quantum state is </span><span class='math-in-toc'>$8\times2^{53}$</span><span> = 64 petabytes. That size is certainly large, but not unachievable by modern computers. IBM&#39;s team used a host of performance enhancing techniques to perform the simulation in 2.5 days. </span></p><p><span>By definition, Google&#39;s team still technically proved quantum supremacy since the quantum computer ran faster than the classical simulation (100 minutes &lt; 2.5 days), even if it wasn&#39;t by their predicted margin of 10,000 years. However, due to the exponential nature of simulating quantum computers, a 100 qubit quantum state would take </span><span class='math-in-toc'>$8\times2^{100}\approx$</span><span> 9,000,000,000,000,000 (9 quadrillion) petabytes to store. This amount of memory is simply unachievable by modern or near future computers. Even if a 53 qubit processor strikes controversy over if it deserves quantum supremacy or not, 100 qubit processors will be developed in the near future and the outcome will be clear.</span></p><p><span>One incredibly important point brought up in IBM&#39;s response is the entire concept of quantum &quot;supremacy&quot;. The nature of quantum  processors are to be devices which coordinate with classical computers, not compete against them. The notion of claiming quantum supremacy is no less ridiculous than claiming &quot;GPU supremacy&quot; because a GPU was shown to be faster at one specific task. The term quantum supremacy was blown out of proportion by the media and broadly misunderstood by the general public. </span></p><hr /><p><span>         </span><a href='../chapter2'><span class='math-in-toc'>$\leftarrow$</span><span>Chapter 2</span></a><span>                                                                                                                                                                                                              </span><a href='../references'><span>References</span><span class='math-in-toc'>$\to$</span></a></p></div>
</body>
</html>